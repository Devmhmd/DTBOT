<img src="img/dtbot-logo.png?raw=true" width="100" height="100"><br>
A loadstressing bot managed via Telegram currently supporting Openstack & AWS 

-----------------

<img src="img/dtbot-telegram.jpg?raw=true" width="350" height="550">
<br>

## Requirements

- Ubuntu 16.04
- Ansible (current version: ansible 2.5.3), Golang (if you want to compile it yourself)


### Quickstart

Run the bash script (install.sh) to install all the required dependencies.

```bash install_script.sh```

<br>
This install script will copy the current compiled binary from /bin into your current system and configure systemd.
Installed packages:<br>
- python-pip (modules: ansible,shade,boto)<br>

After the installation you need to setup your configuration file and credentials source files for Openstack and/or AWS. <br>

The configuration file is ``` /etc/dtbot.conf ``` :
- Telegram Token (can be generated by writing to BotFather "/newbot" : https://telegram.me/botfather)
- Chat ID (if you don't know your id you can write some messages to the newly created bot and then open from this url on your browser: https://api.telegram.org/bot(token)/getUpdates )

The credential files must be placed on:
- /etc/dtbot/os_creds (for Openstack)
- /etc/dtbot/aws_creds (for AWS)


To start the bot process run:
```service dtbot start```
<br>

If you encounter any issue check the log file: /var/log/dtbot.log
<br>

Now before you can run the available commands you must check some parameters on the playbooks:
 - /etc/dtbot/playbooks/aws-create-infra.yaml  (Keyname - Create an SSH-key from your VM running the bot and import this last one on AWS, then use the name of the key in the playbook aws-create-infra.yaml)
 - /etc/dtbot/playbooks/create-infra.yaml (Depending on your Openstack provider you need to adjust the "flavor:" and "image:" 
 - /etc/dtbot/playbooks/info.yaml,ddos.yaml (Same as above ..Openstack flavor,image)

### Usage

All the available commands can be viewed by sending the message /help to the Bot:
```
/help - shows this output
Examples:
/load <URL> <Num Clients> <Seconds> <Num Instances used>
/create <Num Instances>
/destroy <Num Instances>
/stop <Num Instances> ... The Num instances is a sequential number, if i deploy 10 Instances with /create 10 the next time i re-launch the command will not deploy another 10 instances but will only check that instances from 0-10 are present... The same for /stop /load and /destroy
/create_aws <Num Instances>.. every time the command is launched new instances will be deployed
/destory_aws (shuts off all VMS Accessible via the ssh key provided so create a separate key.. Stresser nodes will be deleted on shutoff)
/load_aws <URL> <Num Clients> <Seconds>..
/loadj_aws - Downloads custom jmx and execute it on aws ..
/loadj <URL> <Total nodes> - Downloads custom jmx and execute it on Openstack. ..
/load_custom <URL> <Total nodes> .. start loadstressers and executes custom bash script provided on Openstack creds ..
/load_custom_aws <URL> .. start loadstressers and executes custom bash script provided on AWS nodes...
```


## Work Flow
This is the basic concept explained with a diagram: <br>
<img src="img/dtbot-diagram.png?raw=true">

Working on Ubuntu 16.04 and Ansible 2.5.3

## Contributors

Feel free to open issues or send me an email


## License

Code distributed under GPLv3 licence.
